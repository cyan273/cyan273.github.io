<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Shell基础脚本</title>
    <link href="/posts/a9344153.html"/>
    <url>/posts/a9344153.html</url>
    
    <content type="html"><![CDATA[<h1 id="基础脚本"><a href="#基础脚本" class="headerlink" title="基础脚本"></a>基础脚本</h1><h2 id="1、多个命令"><a href="#1、多个命令" class="headerlink" title="1、多个命令"></a>1、多个命令</h2><p>如果想让多个命令一起运行，可以将其放在同一行中，彼此之间用分号隔开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">pwd</span> ; <span class="hljs-built_in">who</span><br>/root<br>root     pts/0        2024-12-01 12:10 (192.168.115.1)<br>root     pts/1        2024-12-01 12:10 (192.168.115.1)<br>root@docker:~# <br></code></pre></td></tr></table></figure><h2 id="2、创建-shell-脚本"><a href="#2、创建-shell-脚本" class="headerlink" title="2、创建 shell 脚本"></a>2、创建 shell 脚本</h2><p>在创建 shell 脚本文件时，必须在文件的第一行指定要使用的 shell，格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br></code></pre></td></tr></table></figure><p>正常情况下，# 用作注释行，shell 并不会处理 shell 脚本中的注释行。然而，shell 脚本文件的第一行是个例外，# 后面的 ! 用来告诉 shell 用哪个 shell 来运行脚本。</p><p>在指明 shell 之后，可以在文件的各行输入命令，每行末尾加一个换行符，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> $(ip -4 a show ens33 | grep -oP <span class="hljs-string">&#x27;(?&lt;=inet\s)\d+(\.\d+)&#123;3&#125;&#x27;</span>)<br><br><span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><p>同样的，可以在一行中输入多个命令同时使用分号分隔开</p><p>之前了解了环境变量，shell 会通过 PATH 环境变量来查找命令，查看一下 PATH 的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin<br>root@docker:~# <br></code></pre></td></tr></table></figure><p>PATH 环境变量被设置为用于在其中查找命令的一系列目录，要让 shell 找到脚本文件，可以采用以下方法</p><ul><li>将脚本文件的目录添加到 PATH 环境变量中</li><li>使用绝对路径或者相对路径来引用 shell 脚本文件</li></ul><p>使用绝对路径执行，注意的是用户具有文件的可执行权限时才能正常执行脚本，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# ./1.sh<br>-bash: ./1.sh: Permission denied<br>root@docker:~# <span class="hljs-built_in">chmod</span> +x 1.sh <br>root@docker:~# ./1.sh <br>192.168.115.128<br>/root<br>root@docker:~# <br></code></pre></td></tr></table></figure><h2 id="3、打印输出"><a href="#3、打印输出" class="headerlink" title="3、打印输出"></a>3、打印输出</h2><p>如果要添加文本信息告诉用户脚本执行到哪一步了，可以通过<code>echo</code>命令来实现这一点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">echo</span> The time and <span class="hljs-built_in">date</span> are:<br>The time and <span class="hljs-built_in">date</span> are:<br></code></pre></td></tr></table></figure><p>如果想把字符串和命令输出显示在同一行中，可以使用<code>-n</code>选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;The time and date are: &quot;</span> ; <span class="hljs-built_in">date</span><br>The time and <span class="hljs-built_in">date</span> are: Sun Dec  1 12:35:40 PM UTC 2024<br></code></pre></td></tr></table></figure><h2 id="4、命令替换"><a href="#4、命令替换" class="headerlink" title="4、命令替换"></a>4、命令替换</h2><p>shell 脚本中最有用的特性之一是可以从命令输出中提取信息并将其赋给变量</p><p>有两种方法可以将命令输出赋给变量：</p><ul><li>反引号(&#96;)</li><li>$()格式</li></ul><p>Demo：</p><p>shell 会执行命令替换符号的命令，将其赋值给指定变量，值得注意的时赋值号和命令替换符以及变量之间没有空格</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>test1=$(<span class="hljs-built_in">pwd</span>)<br>test2=`<span class="hljs-built_in">date</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$test1</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$test2</span><br></code></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# ./2.sh <br>/root<br>Sun Dec 1 12:42:32 PM UTC 2024<br>root@docker:~# <br></code></pre></td></tr></table></figure><h2 id="5、重定向输入和输出"><a href="#5、重定向输入和输出" class="headerlink" title="5、重定向输入和输出"></a>5、重定向输入和输出</h2><h3 id="5-1-输出重定向"><a href="#5-1-输出重定向" class="headerlink" title="5.1 输出重定向"></a>5.1 输出重定向</h3><p>使用<code>&gt;</code>来实现该操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">commond &gt; outputfile<br></code></pre></td></tr></table></figure><p>命令返回的信息会被保存到指定的输出文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">ls</span> -lih &gt; 1.<span class="hljs-built_in">log</span><br>root@docker:~# <span class="hljs-built_in">cat</span> 1.<span class="hljs-built_in">log</span> <br>total 16K<br>917521 -rw-r--r-- 1 root root    0 Dec  1 12:47 1.<span class="hljs-built_in">log</span><br>917525 -rwxr-xr-x 1 root root   82 Dec  1 12:24 1.sh<br>917522 -rwxr-xr-x 1 root root   66 Dec  1 12:42 2.sh<br>917510 drwx------ 3 root root 4.0K Nov 14 16:03 snap<br>917519 drwxr-xr-x 2 root root 4.0K Nov 30 15:24 tmp<br>root@docker:~# <br></code></pre></td></tr></table></figure><p>如果该文件存在，则重定向运算符会用新数据覆盖已有的文件，如果该文件不存在，则会使用默认的 unask 设置创建文件</p><p>这一操作将导致覆盖原有文件内容，当我们想要将结果追加到已有文件时，可以使用<code>&gt;&gt;</code>来追加数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">echo</span> `<span class="hljs-built_in">date</span>` &gt;&gt; 1.<span class="hljs-built_in">log</span> <br>root@docker:~# <span class="hljs-built_in">cat</span> 1.<span class="hljs-built_in">log</span> <br>total 16K<br>917521 -rw-r--r-- 1 root root    0 Dec  1 12:47 1.<span class="hljs-built_in">log</span><br>917525 -rwxr-xr-x 1 root root   82 Dec  1 12:24 1.sh<br>917522 -rwxr-xr-x 1 root root   66 Dec  1 12:42 2.sh<br>917510 drwx------ 3 root root 4.0K Nov 14 16:03 snap<br>917519 drwxr-xr-x 2 root root 4.0K Nov 30 15:24 tmp<br>Sun Dec 1 12:51:58 PM UTC 2024<br>root@docker:~# <br></code></pre></td></tr></table></figure><h3 id="5-2-输入重定向"><a href="#5-2-输入重定向" class="headerlink" title="5.2 输入重定向"></a>5.2 输入重定向</h3><p>输入重定向运算符是<code>&lt;</code>，操作基本与输出一致</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &lt; inputfile<br></code></pre></td></tr></table></figure><p>将文件传给<code>wc</code>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">wc</span> &lt; 1.<span class="hljs-built_in">log</span> <br>  7  59 306<br>root@docker:~# <span class="hljs-built_in">wc</span> -l &lt; 1.<span class="hljs-built_in">log</span> <br>7<br>root@docker:~# <span class="hljs-built_in">wc</span> -w &lt; 1.<span class="hljs-built_in">log</span> <br>59<br>root@docker:~# <span class="hljs-built_in">wc</span> --chars &lt; 1.<span class="hljs-built_in">log</span> <br>306<br>root@docker:~# <br></code></pre></td></tr></table></figure><p><code>wc</code>命令可以统计数据中的文本，默认情况下输出的3个值是：</p><ul><li>文本的行数</li><li>文本的单词数</li><li>文本的字节数</li></ul><p>还有另外一种输入重定向的方法，称为内联输入重定向内联输入重定向运算符是<code>&lt;&lt;</code>，除了这个符号，必须指定一个文本标记来划分输入数据的起止，任何字符串都可以作为文本标记，但在数据开始和结尾的文本标记必须一致：</p><p>在命令行中使用内联输入重定向时，shell 会用 PS2 环境变量中定义的次提示符，次提示符会持续显示，以获取更多的输入数据，直到输入了作为文本标记的那个字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">wc</span> &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">&gt; test str 1</span><br><span class="hljs-string">&gt; test str 2</span><br><span class="hljs-string">&gt; EOF</span><br>      2       6      22<br>root@docker:~# <br></code></pre></td></tr></table></figure><h2 id="6、执行数学运算"><a href="#6、执行数学运算" class="headerlink" title="6、执行数学运算"></a>6、执行数学运算</h2><h3 id="6-1-expr-命令"><a href="#6-1-expr-命令" class="headerlink" title="6.1 expr 命令"></a>6.1 expr 命令</h3><p><code>expr</code>命令可在命令行中执行数学运算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">expr</span> 1 + 2<br>3<br>root@docker:~# <br></code></pre></td></tr></table></figure><p>expr 命令能够识别少量算术运算符和字符串运算符，一般不会使用，所以不做过多了解，有需要可自行查找</p><h3 id="6-2-使用方括号"><a href="#6-2-使用方括号" class="headerlink" title="6.2 使用方括号"></a>6.2 使用方括号</h3><p>在 bash 中，要将数学运算结果赋给变量，可以使用$和方括号（$[ operation ]）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# var1=$[1 + 1]<br>root@docker:~# var2=$[2 + 2]<br>root@docker:~# var3=$[<span class="hljs-variable">$var1</span> * (<span class="hljs-variable">$var1</span> + <span class="hljs-variable">$var2</span>)]<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var3</span><br>12<br>root@docker:~# <br></code></pre></td></tr></table></figure><blockquote><p>在使用方括号执行数学运算时，无须担心 shell 会误解乘号或其他符号，shell 清楚方括号内的星号不是通配符</p><p>bash shell 的数学运算符只支持整数运算，zsh 提供了完整的浮点数操作</p></blockquote><h3 id="6-3-浮点数解决方案"><a href="#6-3-浮点数解决方案" class="headerlink" title="6.3 浮点数解决方案"></a>6.3 浮点数解决方案</h3><p>有几种解决方案能够克服 bash 只支持整数运算的限制。最常见的做法是使用内建的 bash 计算器 bc</p><h4 id="1）bc-的基本用法"><a href="#1）bc-的基本用法" class="headerlink" title="1）bc 的基本用法"></a>1）bc 的基本用法</h4><p>bash 计算器能够识别以下内容：</p><ul><li>数字（整数和浮点数）</li><li>变量（简单变量和数组）</li><li>注释（以#或 C 语言中的&#x2F;* *&#x2F;开始的行）</li><li>表达式</li><li>编程语句（比如 if-then 语句）</li><li>函数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# bc<br>bc 1.07.1<br>Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software Foundation, Inc.<br>This is free software with ABSOLUTELY NO WARRANTY.<br>For details <span class="hljs-built_in">type</span> `warranty<span class="hljs-string">&#x27;. </span><br><span class="hljs-string">1 + 1</span><br><span class="hljs-string">2</span><br><span class="hljs-string">5 * 2</span><br><span class="hljs-string">10</span><br><span class="hljs-string">3.14 * 2 * 2 / 3.11</span><br><span class="hljs-string">4</span><br><span class="hljs-string">3.14 * 2 * 2</span><br><span class="hljs-string">12.56</span><br><span class="hljs-string">quit</span><br><span class="hljs-string">root@docker:~# </span><br></code></pre></td></tr></table></figure><p>浮点数运算是由内建变量 scale 控制的,可以指定该变量的大小来保留需要的小数位数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# bc -q<br>3.14 / 4<br>0<br>scale=2<br>3.14/4<br>.78<br>quit<br>root@docker:~# <br></code></pre></td></tr></table></figure><h4 id="2）在脚本中使用-bc"><a href="#2）在脚本中使用-bc" class="headerlink" title="2）在脚本中使用 bc"></a>2）在脚本中使用 bc</h4><p>可以使用<code>echo</code>命令将表达式运算的结果通过<code>|</code>提交给 bc 执行，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">cat</span> 3.sh <br><span class="hljs-comment">#!/bin/bash</span><br>var1=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; scale=2; 3.14 / 5&quot;</span> | bc)<br><span class="hljs-built_in">echo</span> The answer is <span class="hljs-variable">$var1</span><br>root@docker:~# ./3.sh <br>The answer is .62<br>root@docker:~# <br></code></pre></td></tr></table></figure><h2 id="7、退出脚本"><a href="#7、退出脚本" class="headerlink" title="7、退出脚本"></a>7、退出脚本</h2><p>shell 中运行的每个命令都使用退出状态码来告诉 shell 自己已经运行完毕，退出状态码是一个 0～255 的整数值，在命令结束运行时由其传给 shell。你可以获取这个值并在脚本中使用</p><h3 id="7-1-查看退出状态码"><a href="#7-1-查看退出状态码" class="headerlink" title="7.1 查看退出状态码"></a>7.1 查看退出状态码</h3><p>对于成功结束的命令，其退出状态码是 0，对于因错误而结束的命令，其退出状态码是一个正整数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# ifconfig<br>Command <span class="hljs-string">&#x27;ifconfig&#x27;</span> not found, but can be installed with:<br>apt install net-tools<br>root@docker:~# <span class="hljs-built_in">echo</span> $?<br>127<br>root@docker:~# <span class="hljs-built_in">pwd</span><br>/root<br>root@docker:~# <span class="hljs-built_in">echo</span> $?<br>0<br>root@docker:~# <br></code></pre></td></tr></table></figure><h3 id="7-2-exit-命令"><a href="#7-2-exit-命令" class="headerlink" title="7.2 exit 命令"></a>7.2 exit 命令</h3><p>默认情况下，shell 脚本会以脚本中的最后一个命令的退出状态码退出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">cat</span> 3.sh <br><span class="hljs-comment">#!/bin/bash</span><br>var1=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; scale=2; 3.14 / 5&quot;</span> | bc)<br><span class="hljs-built_in">echo</span> The answer is <span class="hljs-variable">$var1</span><br>root@docker:~# ./3.sh <br>The answer is .62<br>root@docker:~# <span class="hljs-built_in">echo</span> $?<br>0<br>root@docker:~# <br></code></pre></td></tr></table></figure><p>你可以改变这种默认行为，返回自己的退出状态码，exit 命令允许在脚本结束时指定一个退出状态码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-built_in">exit</span> 5 &gt;&gt; 3.sh <br>root@docker:~# ./3.sh <br>The answer is .62<br>root@docker:~# <span class="hljs-built_in">echo</span> $?<br>5<br>root@docker:~# <br></code></pre></td></tr></table></figure><h2 id="8、实战演练"><a href="#8、实战演练" class="headerlink" title="8、实战演练"></a>8、实战演练</h2><p>⽤ Shell 写⼀个计算器，通过 read 命令获取⽤⼾输⼊的表达式，表达式的格式设定为 操作数1 运算符 操作数2 ，例如 5 + 3 ，然后利⽤设计的脚本输出运算结果</p><h3 id="read-命令"><a href="#read-命令" class="headerlink" title="read 命令"></a>read 命令</h3><p>Linux read命令⽤于从标准输⼊读取数值。<br>常⽤参数</p><blockquote><p>-p：在读取输⼊前显⽰提⽰信息<br>-r：禁⽌反斜杠转义<br>-a：将输⼊赋值给数组<br>-n：限制输⼊字符数<br>-s：隐藏输⼊字符（常⽤于密码输⼊）<br>-t：设置读取输⼊的超时时间</p></blockquote><h3 id="case-命令"><a href="#case-命令" class="headerlink" title="case 命令"></a>case 命令</h3><p>类似于 switch 命令，基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> <span class="hljs-variable">$var</span> <span class="hljs-keyword">in</span><br>pattern1)<br>... ;;<br>pattern2)<br>...;;<br>*)<br>default ... ;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">cat</span> calc.sh <br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入表达式（格式：操作数1 运算符 操作数2，例如 5 + 3）：&quot;</span> a operator b<br><span class="hljs-keyword">case</span> <span class="hljs-variable">$operator</span> <span class="hljs-keyword">in</span><br>        +) result=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> + <span class="hljs-variable">$b</span>&quot;</span> | bc) ;;<br>        -) result=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> - <span class="hljs-variable">$b</span>&quot;</span> | bc) ;;<br>        \*) result=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> * <span class="hljs-variable">$b</span>&quot;</span> | bc) ;;<br>        /) result=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=2; <span class="hljs-variable">$a</span> / <span class="hljs-variable">$b</span>&quot;</span> | bc) ;;<br>        *)<br>                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;无效的运算符。请输入格式：操作数1 运算符 操作数2，例如 5 + 3&quot;</span><br>                <span class="hljs-built_in">exit</span> 1<br>                ;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;结果是：<span class="hljs-variable">$result</span>&quot;</span><br>root@docker:~# ./calc.sh <br>请输入表达式（格式：操作数1 运算符 操作数2，例如 5 + 3）：1 * 2<br>结果是：2<br>root@docker:~# ./calc.sh <br>请输入表达式（格式：操作数1 运算符 操作数2，例如 5 + 3）：9 / 3<br>结果是：3.00<br>root@docker:~# <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Shell 脚本</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux环境变量</title>
    <link href="/posts/63e3ea5.html"/>
    <url>/posts/63e3ea5.html</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-环境变量"><a href="#Linux-环境变量" class="headerlink" title="Linux 环境变量"></a>Linux 环境变量</h1><blockquote><p>Shell 是一种命令行解释器，它为用户提供了与操作系统交互的界面。通过 Shell，用户可以输入命令来执行各种操作，如运行程序、管理文件和配置系统环境。</p></blockquote><h2 id="1、Shell的类型"><a href="#1、Shell的类型" class="headerlink" title="1、Shell的类型"></a>1、Shell的类型</h2><p>登录系统时，使用什么样的 Shell 取决于个人配置。在<code>/etc/passwd</code>文件中保存了对应用户的默认 Shell</p><p>如下所示，root 用户使用 bash 作为默认 Shell 程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">cat</span> /etc/passwd | <span class="hljs-built_in">head</span> -n 1<br>root:x:0:0:root:/root:/bin/bash<br>root@docker:~# <span class="hljs-built_in">cat</span> /etc/passwd | <span class="hljs-built_in">head</span> -n 1 | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot;:&quot;</span> -f7<br>/bin/bash<br></code></pre></td></tr></table></figure><p>使用 which 命令可以快速找出 bash shell的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">which</span> bash<br>/usr/bin/bash<br></code></pre></td></tr></table></figure><p><code>ls -F</code> 命令在 Linux 中用于列出文件和目录，并在每个条目后附加一个字符以指示其类型。</p><ul><li><code>/</code> 表示目录</li><li><code>*</code> 表示可执行文件</li><li><code>@</code> 表示符号链接</li><li><code>|</code> 表示命名管道（FIFO）</li><li><code>=</code> 表示套接字</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">ls</span> -lF /usr/bin/bash<br>-rwxr-xr-x 1 root root 1396520 Mar 14  2024 /usr/bin/bash*<br></code></pre></td></tr></table></figure><h2 id="2、Linux环境变量"><a href="#2、Linux环境变量" class="headerlink" title="2、Linux环境变量"></a>2、Linux环境变量</h2><p>bash shell中有俩种环境变量</p><ul><li>全局变量</li></ul><p>全局变量对于 shell 会话和所有生成的子 shell 都是可见的。局部变量则只对创建它的 shell 生效</p><p>系统在启动 bash 会话时预置了一些全局变量，系统环境变量基本上会使用大写字母，以区别用户自定义的环境变量</p><p>使用<code>env</code>或者<code>printenv</code>命令来查看全局变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">env</span><br>SHELL=/bin/bash<br>PWD=/root<br>.....<br>SSH_TTY=/dev/pts/0<br>_=/usr/bin/env<br>OLDPWD=/root<br>root@docker:~# <br></code></pre></td></tr></table></figure><p>登录方式也会影响所设置的环境变量，为了快速找到我们需要的环境变量的值，可以使用<code>printenv</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">printenv</span> HOME<br>/root<br></code></pre></td></tr></table></figure><p>在引用某个环境变量时，必须在变量前加上<code>$</code>符号</p><p>使用<code>echo</code>命令显示变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span><br>/root<br></code></pre></td></tr></table></figure><ul><li>局部变量</li></ul><p>局部环境变量只能在定义它的进程中可见，Linux 系统默认也定义了标准的局部变量，同时我们也可以自己定义局部变量，这些变量被称为用户自定义局部变量</p><p>局部变量无法使用命令单独显示，但<code>set</code>命令能够显示特定进程的所有环境变量，既包括全局变量、局部变量，也包括用户自定义变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">set</span> | <span class="hljs-built_in">head</span> -n 20<br>BASH=/bin/bash<br>...<br>COMP_WORDBREAKS=$<span class="hljs-string">&#x27; \t\n&quot;\&#x27;</span>&gt;&lt;=;|&amp;(:<span class="hljs-string">&#x27;</span><br><span class="hljs-string">DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/0/bus</span><br><span class="hljs-string">DIRSTACK=()</span><br><span class="hljs-string">EUID=0</span><br><span class="hljs-string">GROUPS=()</span><br><span class="hljs-string">HISTCONTROL=ignoredups:ignorespace</span><br><span class="hljs-string">HISTFILE=/root/.bash_history</span><br></code></pre></td></tr></table></figure><h2 id="3、设置局部用户自定义变量"><a href="#3、设置局部用户自定义变量" class="headerlink" title="3、设置局部用户自定义变量"></a>3、设置局部用户自定义变量</h2><p>使用等号赋值即可，值可以是字符串或数字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# var=test1<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span><br>test1<br></code></pre></td></tr></table></figure><p>如果赋值的字符串包含空格，则必须使用单引号或者双引号来界定该字符串的起止</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# var1=test1 or test2<br>or: <span class="hljs-built_in">command</span> not found<br>root@docker:~# var1=<span class="hljs-string">&#x27;test1 or test2&#x27;</span><br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span><br>test1 or test2<br></code></pre></td></tr></table></figure><p>如果没有引号，则bash shell会将空格后的字符串作为另一个要执行的命令</p><blockquote><p>用户自定义的局部变量应使用小写字母，只有系统变量使用的都是大写字母</p></blockquote><p>在编写 shell 脚本时，变量名、等号和值之间没有空格，如果不注意会导致一些微小错误无法察觉。</p><p>设置的局部变量只能在当前 shell 中使用，如果更换 shell 或者切换到子 shell 则无法适用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# var=<span class="hljs-built_in">test</span><br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span><br><span class="hljs-built_in">test</span><br>root@docker:~# bash<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span><br><br>root@docker:~# <br></code></pre></td></tr></table></figure><h2 id="4、设置全局环境变量"><a href="#4、设置全局环境变量" class="headerlink" title="4、设置全局环境变量"></a>4、设置全局环境变量</h2><p>全局环境变量在设置该变量的父进程所创建的子进程中都是可见的。创建全局环境变量的方法是先创建局部变量，然后再将其导出到全局环境中。</p><p>这可以通过<code>export</code>命令以及要导出的变量名(不加$符号)来实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# var=global<br>root@docker:~# <span class="hljs-built_in">export</span> var<br>root@docker:~# <span class="hljs-built_in">printenv</span> var<br>global<br>root@docker:~# <br></code></pre></td></tr></table></figure><p>修改子 shell 中的全局环境变量并不会影响父 shell 中该变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# bash<br>root@docker:~# var=demo<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span><br>demo<br>root@docker:~# <span class="hljs-built_in">exit</span><br><span class="hljs-built_in">exit</span><br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span><br>global<br></code></pre></td></tr></table></figure><p>子 shell 甚至无法使用 export 命令改变父 shell 中全局环境变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# bash<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span><br>global<br>root@docker:~# <span class="hljs-built_in">export</span> var=<span class="hljs-built_in">test</span><br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span><br><span class="hljs-built_in">test</span><br>root@docker:~# <span class="hljs-built_in">exit</span><br><span class="hljs-built_in">exit</span><br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span><br>global<br>root@docker:~# <br></code></pre></td></tr></table></figure><h2 id="5、删除环境变量"><a href="#5、删除环境变量" class="headerlink" title="5、删除环境变量"></a>5、删除环境变量</h2><p>使用<code>unset</code>命令取消全局变量，在引用环境变量时不要使用<code>$</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">export</span> var=<span class="hljs-built_in">test</span><br>root@docker:~# <span class="hljs-built_in">printenv</span> var<br><span class="hljs-built_in">test</span><br>root@docker:~# <span class="hljs-built_in">unset</span> var<br>root@docker:~# <span class="hljs-built_in">printenv</span> var<br>root@docker:~# <br></code></pre></td></tr></table></figure><blockquote><p>如果要获取变量包含的值则使用<code>$</code>，在操作变量时使用其本身即可</p><p>同时要注意处理全局变量时，如果在子进程删除了一个全局变量，则该操作只对该进程以及对应的子进场有效，无法对父进程产生影响</p></blockquote><h2 id="6、默认的-shell-环境变量"><a href="#6、默认的-shell-环境变量" class="headerlink" title="6、默认的 shell 环境变量"></a>6、默认的 shell 环境变量</h2><p>在默认情况下，bash shell 会用一些特定的环境变量来定义系统环境。由于 bash shell 源自最初的 Unix Bourne shell，因此也保留了 Unix Bourne shell 中定义的那些环境变量</p><table><thead><tr><th align="center">变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">HOME</td><td align="center">当前用户的主目录</td></tr><tr><td align="center">OPTIND</td><td align="center">由 getopt 命令处理的最后一个选项参数的索引</td></tr><tr><td align="center">PATH</td><td align="center">shell 查找命令时使用的目录列表，以冒号分隔</td></tr><tr><td align="center">PS1</td><td align="center">shell 命令行的主提示符</td></tr><tr><td align="center">PS2</td><td align="center">shell 命令行的次提示符</td></tr></tbody></table><p>除了默认的 Bourne 环境变量，bash shell 还提供一些自有的变量，下面列出一小部分</p><table><thead><tr><th align="center">变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">BASH</td><td align="center">bash shell 当前实例的完整路径名</td></tr><tr><td align="center">BASH_ALIASES</td><td align="center">关联数组，包含当前已设置的别名</td></tr><tr><td align="center">BASH_VERSION</td><td align="center">bash shell 当前实例的版本号</td></tr><tr><td align="center">BASH_ENV</td><td align="center">如果设置的话，bash 脚本会在运行前先尝试运行该变量定义的启动文件</td></tr><tr><td align="center">BASH_SUBSHELL</td><td align="center">当前子 shell 环境的嵌套级别（初始值是 0）</td></tr><tr><td align="center">BASH_VERSINFO</td><td align="center">数组变量，包含 bash shell 当前实例的主版本号和次版本号</td></tr><tr><td align="center">BASHOPTS</td><td align="center">当前启用的 bash shell 选项</td></tr><tr><td align="center">BASHPID</td><td align="center">当前 bash 进程的 PID</td></tr></tbody></table><h2 id="7、设置-PATH-环境变量"><a href="#7、设置-PATH-环境变量" class="headerlink" title="7、设置 PATH 环境变量"></a>7、设置 PATH 环境变量</h2><p>当在 shell CLI中输入一个外部命令时，shell 必须搜索系统，从中找到相对于的程序。PTAH 环境变量定义了查询命令和程序和目录以及其对应的优先级，当配置不当时可能会导致一些权限问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin<br>root@docker:~# <br></code></pre></td></tr></table></figure><p>PATH 中的目录之间以冒号分隔，优先使用左边的环境变量，如果使用的命令或者程序所在位置没有包括在环境变量中，那么在没有使用绝对路径的情况下，shell时无法找到的</p><p>添加目录到环境变量时，只需在 PATH 各个目录中添加并且以冒号分隔即可，如何将新目录的绝对路径添加到其中</p><p>编写一个 shell 脚本，打印当前的 IPv4 地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> $(ip -4 a show ens33 | grep -oP <span class="hljs-string">&#x27;(?&lt;=inet\s)\d+(\.\d+)&#123;3&#125;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>赋予执行权限并将绝对路径添加到环境变量中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">chmod</span> +x 1.sh <br>root@docker:~# PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$PWD</span><br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin/root:/root<br>root@docker:~# <br></code></pre></td></tr></table></figure><p>切换到其它目录执行脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# l<br>1.sh*  snap/  tmp/<br>root@docker:~# <span class="hljs-built_in">cd</span> tmp/<br>root@docker:~/tmp# l<br>root@docker:~/tmp# 1.sh <br>192.168.115.128<br>root@docker:~/tmp# <br></code></pre></td></tr></table></figure><blockquote><p>如果希望程序位置也可用于子 shell，则务必确保将修改后的 PATH 环境变量导出。</p></blockquote><p>对于 PATH 变量的修改只能持续到退出或重启系统。这种效果并不能一直奏效。</p><h2 id="8、定位系统环境变量"><a href="#8、定位系统环境变量" class="headerlink" title="8、定位系统环境变量"></a>8、定位系统环境变量</h2><p>当你登录 Linux 系统启动 bash shell 时，默认情况下 bash 会在几个文件中查找命令。这些文件称作启动文件或环境文件。bash 进程的启动文件取决于你启动 bash shell 的方式。启动 bash shell有以下 3 种方式：</p><ul><li>登录时作为默认登录 shell</li><li>作为交互式 shell，通过生成子 shell 启动</li><li>作为运行脚本的非交互式 shell</li></ul><h3 id="8-1-登录shell"><a href="#8-1-登录shell" class="headerlink" title="8.1 登录shell"></a>8.1 登录shell</h3><p>当登录 Linux 系统时，bash shell会作为登录 shell 启动，登录 shell 通常会从5个不同的启动文件中读取命令</p><ul><li>&#x2F;etc&#x2F;profile</li><li>$HOME&#x2F;.bash_profile</li><li>$HOME&#x2F;.bashrc</li><li>$HOME&#x2F;.bash_login</li><li>$HOME&#x2F;.profile</li></ul><p>&#x2F;etc&#x2F;profile 文件是系统中默认的 bash shell 的主启动文件。系统中的每个用户登录时都会执行这个启动文件。</p><h4 id="1）-etc-profile-文件"><a href="#1）-etc-profile-文件" class="headerlink" title="1）&#x2F;etc&#x2F;profile 文件"></a>1）&#x2F;etc&#x2F;profile 文件</h4><p>&#x2F;etc&#x2F;profile文件是bash shell默认的主启动文件。只要登录Linux系统，bash就会执行&#x2F;etc&#x2F;profile启动文件中的命令，不同的 Linux 发行版在这个文件中放置了不同的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">cat</span> /etc/profile<br><span class="hljs-comment"># /etc/profile: system-wide .profile file for the Bourne shell (sh(1))</span><br><span class="hljs-comment"># and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PS1-&#125;</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BASH-&#125;</span>&quot;</span> ] &amp;&amp; [ <span class="hljs-string">&quot;<span class="hljs-variable">$BASH</span>&quot;</span> != <span class="hljs-string">&quot;/bin/sh&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-comment"># The file bash.bashrc already sets the default PS1.</span><br>    <span class="hljs-comment"># PS1=&#x27;\h:\w\$ &#x27;</span><br>    <span class="hljs-keyword">if</span> [ -f /etc/bash.bashrc ]; <span class="hljs-keyword">then</span><br>      . /etc/bash.bashrc<br>    <span class="hljs-keyword">fi</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-subst">$(id -u)</span>&quot;</span> -eq 0 ]; <span class="hljs-keyword">then</span><br>      PS1=<span class="hljs-string">&#x27;# &#x27;</span><br>    <span class="hljs-keyword">else</span><br>      PS1=<span class="hljs-string">&#x27;$ &#x27;</span><br>    <span class="hljs-keyword">fi</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ -d /etc/profile.d ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> /etc/profile.d/*.sh; <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> [ -r <span class="hljs-variable">$i</span> ]; <span class="hljs-keyword">then</span><br>      . <span class="hljs-variable">$i</span><br>    <span class="hljs-keyword">fi</span><br>  <span class="hljs-keyword">done</span><br>  <span class="hljs-built_in">unset</span> i<br><span class="hljs-keyword">fi</span><br>root@docker:~# <br></code></pre></td></tr></table></figure><p>在文件中，使用 for 来迭代&#x2F;etc&#x2F;profile.d 目录下的所有文件。这为 Linux 系统提供了一个放置特定应用程序启动文件和&#x2F;或管理员自定义启动文件<br>的地方，shell 会在用户登录时执行这些文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">ls</span> -liah /etc/profile.d<br>total 40K<br>786497 drwxr-xr-x  2 root root 4.0K Sep 11 14:24 .<br>786433 drwxr-xr-x 96 root root 4.0K Nov 18 12:56 ..<br>787786 -rw-r--r--  1 root root   96 Oct 15  2021 01-locale-fix.sh<br>787790 -rw-r--r--  1 root root  835 Jul 26 02:57 apps-bin-path.sh<br>787791 -rw-r--r--  1 root root  726 Nov 15  2021 bash_completion.sh<br>787792 -rw-r--r--  1 root root 1.1K Aug 17  2023 gawk.csh<br>787793 -rw-r--r--  1 root root  757 Aug 17  2023 gawk.sh<br>787787 -rw-r--r--  1 root root 1.6K Feb 17  2020 Z97-byobu.sh<br>787789 -rwxr-xr-x  1 root root  841 Jul 11 21:27 Z99-cloudinit-warnings.sh<br>787788 -rwxr-xr-x  1 root root 3.4K Jul 11 21:27 Z99-cloud-locale-test.sh<br></code></pre></td></tr></table></figure><p>大部分应用程序会创建两个启动文件：一个供 bash shell 使用（扩展名为<code>.sh</code>），另一个供 C shell 使用（扩展名为<code>.csh</code>）。</p><h4 id="2）-HOME-目录下的启动文件"><a href="#2）-HOME-目录下的启动文件" class="headerlink" title="2）$HOME 目录下的启动文件"></a>2）$HOME 目录下的启动文件</h4><p>其余的启动文件都用于同一个目的：提供用户专属的启动文件来定义该用户所用到的环境变量，大多数 Linux 发行版只用这 4 个启动文件中的一两个</p><ul><li>$HOME&#x2F;.bash_profile</li><li>$HOME&#x2F;.bashrc</li><li>$HOME&#x2F;.bash_login</li><li>$HOME&#x2F;.profile</li></ul><p>这些文件都以点号开头，说明属于隐藏文件，因为它们位于用户的$HOME 目录下，所以每个用户可以对其编辑并添加自己的环境变量，其中的环境变量会在每次启动 bash shell 会话时生效</p><p>shell 会按照下列顺序执行第一个被找到的文件，余下的则被忽略</p><ul><li>$HOME&#x2F;.bash_profile</li><li>$HOME&#x2F;.bash_login</li><li>$HOME&#x2F;.profile</li></ul><blockquote><p>列表中并没有$HOME&#x2F;.bashrc 文件，这是因为该文件通常通过其他文件运行</p><p>$HOME 代表某个用户的主目录，和波浪号（~）的效果一样</p></blockquote><h3 id="8-2-交互式-shell-进程"><a href="#8-2-交互式-shell-进程" class="headerlink" title="8.2 交互式 shell 进程"></a>8.2 交互式 shell 进程</h3><p>如果不是在登录系统时启动的 bash shell（比如在命令行中输入 bash），那么这时的 shell 称作交互式 shell，与登录 shell 一样，交互式 shell 提供了命令行提示符供用户输入命令，作为交互式 shell 启动的 bash 并不处理&#x2F;etc&#x2F;profile 文件，只检查用户$HOME 目录中的.bashrc文件</p><p><code>.bashrc</code>文件会做两件事：首先，检查&#x2F;etc 目录下的通用 bashrc 文件；其次，为用户提供一个定制自己的命令别名和脚本函数的地方</p><p><code>alias</code>设置别名方式为<code>alias t=tree</code>，给使用的命令(可以添加参数)设置别名，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# t<br>t: <span class="hljs-built_in">command</span> not found<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias t=&#x27;tree -L 2&#x27;&quot;</span> &gt;&gt; .bashrc <br>root@docker:~# <span class="hljs-built_in">source</span> .bashrc <br>root@docker:~# t .<br>.<br>├── 1.sh<br>├── snap<br>│   └── lxd<br>└── tmp<br><br>3 directories, 1 file<br>root@docker:~# <br></code></pre></td></tr></table></figure><h3 id="8-3-非交互式-shell"><a href="#8-3-非交互式-shell" class="headerlink" title="8.3 非交互式 shell"></a>8.3 非交互式 shell</h3><p>系统执行 shell 脚本时用的就是这种 shell。不同之处在于它没有命令行提示符。但是，当你在系统中运行脚本时，也许希望能够运行一些特定的启动命令。</p><blockquote><p>脚本能以不同的方式执行，只有部分执行方式会启动子 shell</p></blockquote><p>为了处理这种情况，bash shell 提供了 BASH_ENV 环境变量。当 shell 启动一个非交互式 shell进程时，会检查这个环境变量以查看要执行的启动文件名。如果有指定的文件，则 shell 会执行该文件里的命令，这通常包括 shell 脚本变量设置。</p><p>如果未设置 BASH_ENV 变量，子 shell 会继承父 shell 的导出变量</p><p>如果父 shell 是登录 shell，在&#x2F;etc&#x2F;profile 文件、&#x2F;etc&#x2F;profile.d&#x2F;*.sh 文件和$HOME&#x2F;.bashrc 文件中设置并导出了变量，那么用于执行脚本的子 shell 就能继承这些变量</p><blockquote><p>任何由父 shell 设置但未导出的变量都是局部变量，不会被子 shell 继承</p></blockquote><p>对于那些不启动子 shell 的脚本，变量已经存在于当前 shell 中了,就算没有设置 BASH_ENV，也可以使用当前 shell 的局部变量和全局变量</p><h3 id="8-4-环境变量持久化"><a href="#8-4-环境变量持久化" class="headerlink" title="8.4 环境变量持久化"></a>8.4 环境变量持久化</h3><p>在大多数发行版中，保存个人用户永久性 bash shell 变量的最佳地点是<code>$HOME/.bashrc</code> 文件，这适用于所有类型的 shell 进程。但如果设置了 BASH_ENV 变量，除非值为<code>$HOME/.bashrc</code>，否则，应该将非交互式 shell 的用户变量放在别的地方</p><blockquote><p>图形化界面组成部分（比如 GUI 客户端）的环境变量可能需要在另外一些配置文件中设置，这和设置 bash shell 环境变量的文件不一样</p></blockquote><h2 id="9、数组变量"><a href="#9、数组变量" class="headerlink" title="9、数组变量"></a>9、数组变量</h2><p>要为某个环境变量设置多个值，可以把值放在圆括号中，值与值之间以空格分隔</p><p>直接打印数组名称时打印第一个变量值，同样的可以使用下标获取其对应的值，具体操作如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# arr=(1 2 3 4 5)<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$arr</span><br>1<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[2]&#125;</span><br>3<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[-1]&#125;</span><br>5<br>root@docker:~# <br></code></pre></td></tr></table></figure><p>要显示整个数组变量，可以用通配符*作为索引：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[*]&#125;</span><br>1 2 3 4 5<br>root@docker:~# <br></code></pre></td></tr></table></figure><p>也可以改变某个索引位置上的值，可以使用<code>unset</code>命令来删除索引对应的值，但这不会改变索引，如果打印该索引值时会返回一个空值，可以在<code>unset</code>命令后面跟上数组名来删除整个数组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[*]&#125;</span><br>1 2 3 4 5<br>root@docker:~# arr[3]=8<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[*]&#125;</span><br>1 2 3 8 5<br>root@docker:~# <span class="hljs-built_in">unset</span> arr[3]<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[*]&#125;</span><br>1 2 3 5<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[3]&#125;</span><br><br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[4]&#125;</span><br>5<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[2]&#125;</span><br>3<br>root@docker:~# <span class="hljs-built_in">unset</span> arr<br>root@docker:~# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[*]&#125;</span><br><br>root@docker:~# <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Shell 脚本</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
